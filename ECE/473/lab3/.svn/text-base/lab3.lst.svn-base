
lab3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800100  000005c0  00000654  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000005c0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000014  00800120  00800120  00000674  2**0
                  ALLOC
  3 .stab         00002130  00000000  00000000  00000674  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ee6  00000000  00000000  000027a4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 59 02 	jmp	0x4b2	; 0x4b2 <__vector_12>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 c0 00 	jmp	0x180	; 0x180 <__vector_16>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e0 ec       	ldi	r30, 0xC0	; 192
  a0:	f5 e0       	ldi	r31, 0x05	; 5
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a0 32       	cpi	r26, 0x20	; 32
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a0 e2       	ldi	r26, 0x20	; 32
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a4 33       	cpi	r26, 0x34	; 52
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 f7 00 	call	0x1ee	; 0x1ee <main>
  c6:	0c 94 de 02 	jmp	0x5bc	; 0x5bc <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <init_timer>:
 * controls the frequency at which the buttons are
 * checked for its pressed state.
 ******************************************************/
void init_timer()
{
	TIMSK |= (1 << TOIE0);             //enable interrupts
  ce:	87 b7       	in	r24, 0x37	; 55
  d0:	81 60       	ori	r24, 0x01	; 1
  d2:	87 bf       	out	0x37, r24	; 55
	TCCR0 |= (1 << CS02) | (1 << CS00);  //normal mode, prescale by 128
  d4:	83 b7       	in	r24, 0x33	; 51
  d6:	85 60       	ori	r24, 0x05	; 5
  d8:	83 bf       	out	0x33, r24	; 51
}
  da:	08 95       	ret

000000dc <update_number>:

uint16_t update_number(struct encoder_state *state, uint16_t number)
{
  dc:	fc 01       	movw	r30, r24
	if (mode == 0x03)
  de:	80 91 33 01 	lds	r24, 0x0133
  e2:	83 30       	cpi	r24, 0x03	; 3
  e4:	b9 f0       	breq	.+46     	; 0x114 <update_number+0x38>
		return number; // both modes are active so do nothing

	if (state->left_dir == STOPPED && state->right_dir == STOPPED)
  e6:	90 81       	ld	r25, Z
  e8:	92 30       	cpi	r25, 0x02	; 2
  ea:	41 f1       	breq	.+80     	; 0x13c <update_number+0x60>
		return number; // the encoders are stopped so do nothing

	/* set the increment based on the current mode */
	uint8_t increment = 0;
	switch(mode) {
  ec:	a0 91 33 01 	lds	r26, 0x0133
  f0:	a3 30       	cpi	r26, 0x03	; 3
  f2:	90 f0       	brcs	.+36     	; 0x118 <update_number+0x3c>
  f4:	80 e0       	ldi	r24, 0x00	; 0
	case 0x00: increment = 1; break;
	case 0x01: increment = 2; break;
	case 0x02: increment = 4; break;
	}

	if (state->left_dir == FORWARD || state->right_dir == FORWARD) {
  f6:	91 30       	cpi	r25, 0x01	; 1
  f8:	b9 f0       	breq	.+46     	; 0x128 <update_number+0x4c>
  fa:	21 81       	ldd	r18, Z+1	; 0x01
  fc:	21 30       	cpi	r18, 0x01	; 1
  fe:	a1 f0       	breq	.+40     	; 0x128 <update_number+0x4c>
		number += increment; // add the increment if either encoder is going forward
		if (number > 1023)
			number -= 1023; // rollover positive
	}else if (state->left_dir == REVERSE || state->right_dir == REVERSE) {
 100:	99 23       	and	r25, r25
 102:	01 f5       	brne	.+64     	; 0x144 <update_number+0x68>
		if (number < increment)
 104:	90 e0       	ldi	r25, 0x00	; 0
 106:	68 17       	cp	r22, r24
 108:	79 07       	cpc	r23, r25
 10a:	10 f4       	brcc	.+4      	; 0x110 <update_number+0x34>
			number += 1024; // rollover negative
 10c:	60 50       	subi	r22, 0x00	; 0
 10e:	7c 4f       	sbci	r23, 0xFC	; 252

		number -= increment; // sub the increment if either encoder is going reverse
 110:	68 1b       	sub	r22, r24
 112:	79 0b       	sbc	r23, r25
	}

	return number;
}
 114:	cb 01       	movw	r24, r22
 116:	08 95       	ret
	if (state->left_dir == STOPPED && state->right_dir == STOPPED)
		return number; // the encoders are stopped so do nothing

	/* set the increment based on the current mode */
	uint8_t increment = 0;
	switch(mode) {
 118:	bb 27       	eor	r27, r27
 11a:	a7 fd       	sbrc	r26, 7
 11c:	b0 95       	com	r27
 11e:	af 5e       	subi	r26, 0xEF	; 239
 120:	be 4f       	sbci	r27, 0xFE	; 254
 122:	8c 91       	ld	r24, X
	case 0x00: increment = 1; break;
	case 0x01: increment = 2; break;
	case 0x02: increment = 4; break;
	}

	if (state->left_dir == FORWARD || state->right_dir == FORWARD) {
 124:	91 30       	cpi	r25, 0x01	; 1
 126:	49 f7       	brne	.-46     	; 0xfa <update_number+0x1e>
		number += increment; // add the increment if either encoder is going forward
 128:	68 0f       	add	r22, r24
 12a:	71 1d       	adc	r23, r1
		if (number > 1023)
 12c:	84 e0       	ldi	r24, 0x04	; 4
 12e:	60 30       	cpi	r22, 0x00	; 0
 130:	78 07       	cpc	r23, r24
 132:	80 f3       	brcs	.-32     	; 0x114 <update_number+0x38>
			number -= 1023; // rollover positive
 134:	6f 5f       	subi	r22, 0xFF	; 255
 136:	73 40       	sbci	r23, 0x03	; 3

		number -= increment; // sub the increment if either encoder is going reverse
	}

	return number;
}
 138:	cb 01       	movw	r24, r22
 13a:	08 95       	ret
uint16_t update_number(struct encoder_state *state, uint16_t number)
{
	if (mode == 0x03)
		return number; // both modes are active so do nothing

	if (state->left_dir == STOPPED && state->right_dir == STOPPED)
 13c:	81 81       	ldd	r24, Z+1	; 0x01
 13e:	82 30       	cpi	r24, 0x02	; 2
 140:	a9 f6       	brne	.-86     	; 0xec <update_number+0x10>
 142:	e8 cf       	rjmp	.-48     	; 0x114 <update_number+0x38>

	if (state->left_dir == FORWARD || state->right_dir == FORWARD) {
		number += increment; // add the increment if either encoder is going forward
		if (number > 1023)
			number -= 1023; // rollover positive
	}else if (state->left_dir == REVERSE || state->right_dir == REVERSE) {
 144:	22 23       	and	r18, r18
 146:	31 f7       	brne	.-52     	; 0x114 <update_number+0x38>
 148:	dd cf       	rjmp	.-70     	; 0x104 <update_number+0x28>

0000014a <set_graph>:

	return number;
}

char set_graph(char buttons, char mode)
{
 14a:	df 93       	push	r29
 14c:	cf 93       	push	r28
 14e:	0f 92       	push	r0
 150:	cd b7       	in	r28, 0x3d	; 61
 152:	de b7       	in	r29, 0x3e	; 62
	if (ISSET(buttons, 0))
 154:	28 2f       	mov	r18, r24
 156:	33 27       	eor	r19, r19
 158:	27 fd       	sbrc	r18, 7
 15a:	30 95       	com	r19
 15c:	20 ff       	sbrs	r18, 0
 15e:	02 c0       	rjmp	.+4      	; 0x164 <set_graph+0x1a>
		mode ^= 0x01; // toggle the mode
 160:	81 e0       	ldi	r24, 0x01	; 1
 162:	68 27       	eor	r22, r24

	if (ISSET(buttons, 1))
 164:	21 ff       	sbrs	r18, 1
 166:	02 c0       	rjmp	.+4      	; 0x16c <set_graph+0x22>
		mode ^= 0x02; // toggle the mode
 168:	82 e0       	ldi	r24, 0x02	; 2
 16a:	68 27       	eor	r22, r24

	update_graph(mode); // update the graph with the mode
 16c:	86 2f       	mov	r24, r22
 16e:	69 83       	std	Y+1, r22	; 0x01
 170:	0e 94 54 02 	call	0x4a8	; 0x4a8 <update_graph>
	return mode;
}
 174:	69 81       	ldd	r22, Y+1	; 0x01
 176:	86 2f       	mov	r24, r22
 178:	0f 90       	pop	r0
 17a:	cf 91       	pop	r28
 17c:	df 91       	pop	r29
 17e:	08 95       	ret

00000180 <__vector_16>:
/******************************************************
 * The interrupt vector that checks the state of the
 * buttons and alters the displayed number accordingly.
 ******************************************************/
ISR(TIMER0_OVF_vect)
{
 180:	1f 92       	push	r1
 182:	0f 92       	push	r0
 184:	0f b6       	in	r0, 0x3f	; 63
 186:	0f 92       	push	r0
 188:	0b b6       	in	r0, 0x3b	; 59
 18a:	0f 92       	push	r0
 18c:	11 24       	eor	r1, r1
 18e:	2f 93       	push	r18
 190:	3f 93       	push	r19
 192:	4f 93       	push	r20
 194:	5f 93       	push	r21
 196:	6f 93       	push	r22
 198:	7f 93       	push	r23
 19a:	8f 93       	push	r24
 19c:	9f 93       	push	r25
 19e:	af 93       	push	r26
 1a0:	bf 93       	push	r27
 1a2:	ef 93       	push	r30
 1a4:	ff 93       	push	r31
	enable_buttons(); // enable the buttons and disable the display
 1a6:	0e 94 e7 01 	call	0x3ce	; 0x3ce <enable_buttons>
	pina = poll_buttons(PINA); // get the button state
 1aa:	89 b3       	in	r24, 0x19	; 25
 1ac:	0e 94 10 02 	call	0x420	; 0x420 <poll_buttons>
 1b0:	80 93 30 01 	sts	0x0130, r24
	enable_leds(); // re-enable the leds
 1b4:	0e 94 47 01 	call	0x28e	; 0x28e <enable_leds>

	mode = set_graph(pina, mode);
 1b8:	80 91 30 01 	lds	r24, 0x0130
 1bc:	60 91 33 01 	lds	r22, 0x0133
 1c0:	0e 94 a5 00 	call	0x14a	; 0x14a <set_graph>
 1c4:	80 93 33 01 	sts	0x0133, r24
}
 1c8:	ff 91       	pop	r31
 1ca:	ef 91       	pop	r30
 1cc:	bf 91       	pop	r27
 1ce:	af 91       	pop	r26
 1d0:	9f 91       	pop	r25
 1d2:	8f 91       	pop	r24
 1d4:	7f 91       	pop	r23
 1d6:	6f 91       	pop	r22
 1d8:	5f 91       	pop	r21
 1da:	4f 91       	pop	r20
 1dc:	3f 91       	pop	r19
 1de:	2f 91       	pop	r18
 1e0:	0f 90       	pop	r0
 1e2:	0b be       	out	0x3b, r0	; 59
 1e4:	0f 90       	pop	r0
 1e6:	0f be       	out	0x3f, r0	; 63
 1e8:	0f 90       	pop	r0
 1ea:	1f 90       	pop	r1
 1ec:	18 95       	reti

000001ee <main>:

int main()
{
 1ee:	cf 92       	push	r12
 1f0:	df 92       	push	r13
 1f2:	ef 92       	push	r14
 1f4:	ff 92       	push	r15
 1f6:	0f 93       	push	r16
 1f8:	1f 93       	push	r17
 1fa:	df 93       	push	r29
 1fc:	cf 93       	push	r28
 1fe:	cd b7       	in	r28, 0x3d	; 61
 200:	de b7       	in	r29, 0x3e	; 62
 202:	29 97       	sbiw	r28, 0x09	; 9
 204:	0f b6       	in	r0, 0x3f	; 63
 206:	f8 94       	cli
 208:	de bf       	out	0x3e, r29	; 62
 20a:	0f be       	out	0x3f, r0	; 63
 20c:	cd bf       	out	0x3d, r28	; 61
	DDRB  = 0xF0;   //set port bits 4-7 B as outputs
 20e:	80 ef       	ldi	r24, 0xF0	; 240
 210:	87 bb       	out	0x17, r24	; 23
	DDRD  = 0x00;   //set port D all inputs 
 212:	11 ba       	out	0x11, r1	; 17
	PORTD = 0xFF;   //set port D all pullups 
 214:	0f ef       	ldi	r16, 0xFF	; 255
 216:	02 bb       	out	0x12, r16	; 18

	struct display output;
	init_display_struct(&output); // init the struct the holds the display state
 218:	85 e0       	ldi	r24, 0x05	; 5
 21a:	c8 2e       	mov	r12, r24
 21c:	d1 2c       	mov	r13, r1
 21e:	cc 0e       	add	r12, r28
 220:	dd 1e       	adc	r13, r29
 222:	c6 01       	movw	r24, r12
 224:	0e 94 4f 01 	call	0x29e	; 0x29e <init_display_struct>

	pina = 0xFF;
 228:	00 93 30 01 	sts	0x0130, r16
 * controls the frequency at which the buttons are
 * checked for its pressed state.
 ******************************************************/
void init_timer()
{
	TIMSK |= (1 << TOIE0);             //enable interrupts
 22c:	87 b7       	in	r24, 0x37	; 55
 22e:	81 60       	ori	r24, 0x01	; 1
 230:	87 bf       	out	0x37, r24	; 55
	TCCR0 |= (1 << CS02) | (1 << CS00);  //normal mode, prescale by 128
 232:	83 b7       	in	r24, 0x33	; 51
 234:	85 60       	ori	r24, 0x05	; 5
 236:	83 bf       	out	0x33, r24	; 51
	init_display_struct(&output); // init the struct the holds the display state

	pina = 0xFF;
	init_timer(); // init the timer to check for the button states

	enable_leds(); // enable the display
 238:	0e 94 47 01 	call	0x28e	; 0x28e <enable_leds>

	enable_graph(); // enable the bar graph
 23c:	0e 94 4f 02 	call	0x49e	; 0x49e <enable_graph>
	update_graph(OFF); // make sure the bar graph is off
 240:	80 e0       	ldi	r24, 0x00	; 0
 242:	0e 94 54 02 	call	0x4a8	; 0x4a8 <update_graph>

	enable_encoders(); // enable the encoders
 246:	0e 94 c0 02 	call	0x580	; 0x580 <enable_encoders>

	struct encoder_state encoders;
	init_encoder_struct(&encoders);// init the encoder data struct
 24a:	7e 01       	movw	r14, r28
 24c:	08 94       	sec
 24e:	e1 1c       	adc	r14, r1
 250:	f1 1c       	adc	r15, r1
 252:	c7 01       	movw	r24, r14
 254:	0e 94 69 02 	call	0x4d2	; 0x4d2 <init_encoder_struct>

	uint16_t number = 0; // init the number on the display to show 0
	mode = 0;
 258:	10 92 33 01 	sts	0x0133, r1

	sei(); 
 25c:	78 94       	sei
	enable_encoders(); // enable the encoders

	struct encoder_state encoders;
	init_encoder_struct(&encoders);// init the encoder data struct

	uint16_t number = 0; // init the number on the display to show 0
 25e:	00 e0       	ldi	r16, 0x00	; 0
 260:	10 e0       	ldi	r17, 0x00	; 0
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 262:	87 ec       	ldi	r24, 0xC7	; 199
 264:	90 e0       	ldi	r25, 0x00	; 0
 266:	01 97       	sbiw	r24, 0x01	; 1
 268:	f1 f7       	brne	.-4      	; 0x266 <main+0x78>
 26a:	00 c0       	rjmp	.+0      	; 0x26c <main+0x7e>
 26c:	00 00       	nop

	sei(); 
	while (1) {	
		_delay_us(50); // loop delay for the segments
		
		get_direction(&encoders, poll_encoders()); // get the encoder direction
 26e:	0e 94 63 02 	call	0x4c6	; 0x4c6 <poll_encoders>
 272:	68 2f       	mov	r22, r24
 274:	c7 01       	movw	r24, r14
 276:	0e 94 91 02 	call	0x522	; 0x522 <get_direction>
		number = update_number(&encoders, number); // update the led display number
 27a:	c7 01       	movw	r24, r14
 27c:	b8 01       	movw	r22, r16
 27e:	0e 94 6e 00 	call	0xdc	; 0xdc <update_number>
 282:	8c 01       	movw	r16, r24

		update_segment(&output, number); // continuously update the display
 284:	c6 01       	movw	r24, r12
 286:	b8 01       	movw	r22, r16
 288:	0e 94 b5 01 	call	0x36a	; 0x36a <update_segment>
 28c:	ea cf       	rjmp	.-44     	; 0x262 <main+0x74>

0000028e <enable_leds>:
							 SIX, SEVEN, EIGHT, NINE, OFF };

void enable_leds()
{
	// disable the tristate buffer without enabling a segment
	PORTB &= ~(1 << PB4);
 28e:	c4 98       	cbi	0x18, 4	; 24
	PORTB |= (1 << PB6) | (1 << PB5);
 290:	88 b3       	in	r24, 0x18	; 24
 292:	80 66       	ori	r24, 0x60	; 96
 294:	88 bb       	out	0x18, r24	; 24

	//_delay_us(25);

	DDRA = 0xFF; // make PORTA all outputs
 296:	8f ef       	ldi	r24, 0xFF	; 255
 298:	8a bb       	out	0x1a, r24	; 26
	PORTA = 0xFF;
 29a:	8b bb       	out	0x1b, r24	; 27
}
 29c:	08 95       	ret

0000029e <init_display_struct>:

void init_display_struct(struct display *output)
{
 29e:	fc 01       	movw	r30, r24
	output->ones = 0;
 2a0:	10 82       	st	Z, r1
	output->tens = 0;
 2a2:	11 82       	std	Z+1, r1	; 0x01
	output->hundreds = 0;
 2a4:	12 82       	std	Z+2, r1	; 0x02
	output->thousands = 0;
 2a6:	13 82       	std	Z+3, r1	; 0x03

	output->cycle = 0;
 2a8:	14 82       	std	Z+4, r1	; 0x04
}
 2aa:	08 95       	ret

000002ac <set_colon>:

void set_colon(struct display *output)
{

}
 2ac:	08 95       	ret

000002ae <decode_number>:

void decode_number(struct display *output, uint16_t number)
{
 2ae:	0f 93       	push	r16
 2b0:	1f 93       	push	r17
 2b2:	cf 93       	push	r28
 2b4:	df 93       	push	r29
 2b6:	fc 01       	movw	r30, r24
 2b8:	9b 01       	movw	r18, r22
	output->ones = (number%10);
 2ba:	ca e0       	ldi	r28, 0x0A	; 10
 2bc:	d0 e0       	ldi	r29, 0x00	; 0
 2be:	cb 01       	movw	r24, r22
 2c0:	be 01       	movw	r22, r28
 2c2:	0e 94 ca 02 	call	0x594	; 0x594 <__udivmodhi4>
 2c6:	80 83       	st	Z, r24
	output->tens = (number%100)/10;
 2c8:	04 e6       	ldi	r16, 0x64	; 100
 2ca:	10 e0       	ldi	r17, 0x00	; 0
 2cc:	c9 01       	movw	r24, r18
 2ce:	b8 01       	movw	r22, r16
 2d0:	0e 94 ca 02 	call	0x594	; 0x594 <__udivmodhi4>
 2d4:	be 01       	movw	r22, r28
 2d6:	0e 94 ca 02 	call	0x594	; 0x594 <__udivmodhi4>
 2da:	46 2f       	mov	r20, r22
 2dc:	61 83       	std	Z+1, r22	; 0x01
	output->hundreds = (number%1000)/100;
 2de:	c9 01       	movw	r24, r18
 2e0:	68 ee       	ldi	r22, 0xE8	; 232
 2e2:	73 e0       	ldi	r23, 0x03	; 3
 2e4:	0e 94 ca 02 	call	0x594	; 0x594 <__udivmodhi4>
 2e8:	26 2f       	mov	r18, r22
 2ea:	b8 01       	movw	r22, r16
 2ec:	0e 94 ca 02 	call	0x594	; 0x594 <__udivmodhi4>
 2f0:	62 83       	std	Z+2, r22	; 0x02
	output->thousands = number/1000;
 2f2:	23 83       	std	Z+3, r18	; 0x03

	if (output->thousands != 0)
 2f4:	22 23       	and	r18, r18
 2f6:	41 f4       	brne	.+16     	; 0x308 <decode_number+0x5a>
		return;

	output->thousands = BLANK; // turn of digit 4 if thousands is 0
 2f8:	8a e0       	ldi	r24, 0x0A	; 10
 2fa:	83 83       	std	Z+3, r24	; 0x03
	if (output->hundreds != 0)
 2fc:	66 23       	and	r22, r22
 2fe:	21 f4       	brne	.+8      	; 0x308 <decode_number+0x5a>
		return;

	output->hundreds = BLANK; // turn of digit 3 if hundreds is 0
 300:	82 83       	std	Z+2, r24	; 0x02
	if (output->tens != 0)
 302:	44 23       	and	r20, r20
 304:	09 f4       	brne	.+2      	; 0x308 <decode_number+0x5a>
		return;

	output->tens = BLANK; // turn of digit 2 if tens is 0
 306:	81 83       	std	Z+1, r24	; 0x01
}
 308:	df 91       	pop	r29
 30a:	cf 91       	pop	r28
 30c:	1f 91       	pop	r17
 30e:	0f 91       	pop	r16
 310:	08 95       	ret

00000312 <enable_segment>:

void enable_segment(uint8_t segment)
{
	switch (segment) {
 312:	82 30       	cpi	r24, 0x02	; 2
 314:	c9 f0       	breq	.+50     	; 0x348 <enable_segment+0x36>
 316:	83 30       	cpi	r24, 0x03	; 3
 318:	28 f0       	brcs	.+10     	; 0x324 <enable_segment+0x12>
 31a:	83 30       	cpi	r24, 0x03	; 3
 31c:	d1 f0       	breq	.+52     	; 0x352 <enable_segment+0x40>
 31e:	84 30       	cpi	r24, 0x04	; 4
 320:	71 f0       	breq	.+28     	; 0x33e <enable_segment+0x2c>
 322:	08 95       	ret
 324:	88 23       	and	r24, r24
 326:	39 f0       	breq	.+14     	; 0x336 <enable_segment+0x24>
 328:	81 30       	cpi	r24, 0x01	; 1
 32a:	d9 f7       	brne	.-10     	; 0x322 <enable_segment+0x10>
	case 0: // digit 1 enabled: PORTB = 0b?000????
		PORTB &= ~(1 << PB4) & ~(1 << PB5) & ~(1 << PB6);
		break;

	case 1: // digit 2 enabled: PORTB = 0b?001????
		PORTB &= ~(1 << PB5) & ~(1 << PB6);
 32c:	88 b3       	in	r24, 0x18	; 24
 32e:	8f 79       	andi	r24, 0x9F	; 159
 330:	88 bb       	out	0x18, r24	; 24
		PORTB |= (1 << PB4);
 332:	c4 9a       	sbi	0x18, 4	; 24
		break;
 334:	08 95       	ret

void enable_segment(uint8_t segment)
{
	switch (segment) {
	case 0: // digit 1 enabled: PORTB = 0b?000????
		PORTB &= ~(1 << PB4) & ~(1 << PB5) & ~(1 << PB6);
 336:	88 b3       	in	r24, 0x18	; 24
 338:	8f 78       	andi	r24, 0x8F	; 143
 33a:	88 bb       	out	0x18, r24	; 24
		break;
 33c:	08 95       	ret
		PORTB &= ~(1 << PB6);
		PORTB |= (1 << PB4) | (1 << PB5);
		break;

	case 4: // digit 4 enabled: PORTB = 0b?100????
		PORTB &= ~(1 << PB4) & ~(1 << PB5);		
 33e:	88 b3       	in	r24, 0x18	; 24
 340:	8f 7c       	andi	r24, 0xCF	; 207
 342:	88 bb       	out	0x18, r24	; 24
		PORTB |= (1 << PB6);
 344:	c6 9a       	sbi	0x18, 6	; 24
 346:	08 95       	ret
		PORTB &= ~(1 << PB5) & ~(1 << PB6);
		PORTB |= (1 << PB4);
		break;

	case 2: // colons enabled: PORTB = 0b?010????
		PORTB &= ~(1 << PB4) & ~(1 << PB6);
 348:	88 b3       	in	r24, 0x18	; 24
 34a:	8f 7a       	andi	r24, 0xAF	; 175
 34c:	88 bb       	out	0x18, r24	; 24
		PORTB |= (1 << PB5);
 34e:	c5 9a       	sbi	0x18, 5	; 24
		break;
 350:	08 95       	ret

	case 3: // digit 3 enabled: PORTB = 0b?011????
		PORTB &= ~(1 << PB6);
 352:	c6 98       	cbi	0x18, 6	; 24
		PORTB |= (1 << PB4) | (1 << PB5);
 354:	88 b3       	in	r24, 0x18	; 24
 356:	80 63       	ori	r24, 0x30	; 48
 358:	88 bb       	out	0x18, r24	; 24
		break;
 35a:	08 95       	ret

0000035c <set_digit>:
	}
}

void set_digit(uint8_t digit)
{
	PORTA = NUMBERS[digit];
 35c:	e4 e1       	ldi	r30, 0x14	; 20
 35e:	f1 e0       	ldi	r31, 0x01	; 1
 360:	e8 0f       	add	r30, r24
 362:	f1 1d       	adc	r31, r1
 364:	80 81       	ld	r24, Z
 366:	8b bb       	out	0x1b, r24	; 27
}
 368:	08 95       	ret

0000036a <update_segment>:
 
void update_segment(struct display *output, uint16_t number)
{
 36a:	1f 93       	push	r17
 36c:	cf 93       	push	r28
 36e:	df 93       	push	r29
 370:	ec 01       	movw	r28, r24
	decode_number(output, number); // get the 4 digits 
 372:	0e 94 57 01 	call	0x2ae	; 0x2ae <decode_number>
	}
}

void set_digit(uint8_t digit)
{
	PORTA = NUMBERS[digit];
 376:	1f ef       	ldi	r17, 0xFF	; 255
 378:	1b bb       	out	0x1b, r17	; 27
void update_segment(struct display *output, uint16_t number)
{
	decode_number(output, number); // get the 4 digits 

	set_digit(BLANK); // blank before switching to prevent ghosting
	enable_segment(output->cycle); // enable the correct digit
 37a:	8c 81       	ldd	r24, Y+4	; 0x04
 37c:	0e 94 89 01 	call	0x312	; 0x312 <enable_segment>

	switch(output->cycle) { // display the digit based on the segment enabled
 380:	8c 81       	ldd	r24, Y+4	; 0x04
 382:	82 30       	cpi	r24, 0x02	; 2
 384:	f9 f0       	breq	.+62     	; 0x3c4 <update_segment+0x5a>
 386:	83 30       	cpi	r24, 0x03	; 3
 388:	68 f0       	brcs	.+26     	; 0x3a4 <update_segment+0x3a>
 38a:	83 30       	cpi	r24, 0x03	; 3
 38c:	f1 f0       	breq	.+60     	; 0x3ca <update_segment+0x60>
 38e:	84 30       	cpi	r24, 0x04	; 4
 390:	b9 f0       	breq	.+46     	; 0x3c0 <update_segment+0x56>
	case 2: set_digit(BLANK);             break; // colons
	case 3: set_digit(output->hundreds);  break; // hundreds digit
	case 4: set_digit(output->thousands); break; // thousands digit
	}

	output->cycle++; // go to the next segment
 392:	8f 5f       	subi	r24, 0xFF	; 255
 394:	8c 83       	std	Y+4, r24	; 0x04
	if (output->cycle > 4)
 396:	85 30       	cpi	r24, 0x05	; 5
 398:	08 f0       	brcs	.+2      	; 0x39c <update_segment+0x32>
		output->cycle = 0; // go back to the beginning if at the last segment	
 39a:	1c 82       	std	Y+4, r1	; 0x04
}
 39c:	df 91       	pop	r29
 39e:	cf 91       	pop	r28
 3a0:	1f 91       	pop	r17
 3a2:	08 95       	ret
	decode_number(output, number); // get the 4 digits 

	set_digit(BLANK); // blank before switching to prevent ghosting
	enable_segment(output->cycle); // enable the correct digit

	switch(output->cycle) { // display the digit based on the segment enabled
 3a4:	88 23       	and	r24, r24
 3a6:	51 f0       	breq	.+20     	; 0x3bc <update_segment+0x52>
 3a8:	81 30       	cpi	r24, 0x01	; 1
 3aa:	99 f7       	brne	.-26     	; 0x392 <update_segment+0x28>
	}
}

void set_digit(uint8_t digit)
{
	PORTA = NUMBERS[digit];
 3ac:	e9 81       	ldd	r30, Y+1	; 0x01
 3ae:	f0 e0       	ldi	r31, 0x00	; 0
 3b0:	ec 5e       	subi	r30, 0xEC	; 236
 3b2:	fe 4f       	sbci	r31, 0xFE	; 254
 3b4:	80 81       	ld	r24, Z
 3b6:	8b bb       	out	0x1b, r24	; 27
 3b8:	8c 81       	ldd	r24, Y+4	; 0x04
 3ba:	eb cf       	rjmp	.-42     	; 0x392 <update_segment+0x28>
 3bc:	e8 81       	ld	r30, Y
 3be:	f7 cf       	rjmp	.-18     	; 0x3ae <update_segment+0x44>
 3c0:	eb 81       	ldd	r30, Y+3	; 0x03
 3c2:	f5 cf       	rjmp	.-22     	; 0x3ae <update_segment+0x44>
 3c4:	1b bb       	out	0x1b, r17	; 27
 3c6:	8c 81       	ldd	r24, Y+4	; 0x04
	enable_segment(output->cycle); // enable the correct digit

	switch(output->cycle) { // display the digit based on the segment enabled
	case 0: set_digit(output->ones);      break; // ones digit
	case 1: set_digit(output->tens);      break; // tens digit
	case 2: set_digit(BLANK);             break; // colons
 3c8:	e4 cf       	rjmp	.-56     	; 0x392 <update_segment+0x28>
	}
}

void set_digit(uint8_t digit)
{
	PORTA = NUMBERS[digit];
 3ca:	ea 81       	ldd	r30, Y+2	; 0x02
 3cc:	f0 cf       	rjmp	.-32     	; 0x3ae <update_segment+0x44>

000003ce <enable_buttons>:
#define BYTE 8

void enable_buttons()
{
	// disable the segments without enabling the tristate buffer
	PORTB &= ~(1 << PB4);
 3ce:	c4 98       	cbi	0x18, 4	; 24
	PORTB |= (1 << PB6) | (1 << PB5);
 3d0:	88 b3       	in	r24, 0x18	; 24
 3d2:	80 66       	ori	r24, 0x60	; 96
 3d4:	88 bb       	out	0x18, r24	; 24

	DDRA = 0; // change DDRA to accept input
 3d6:	1a ba       	out	0x1a, r1	; 26
	PORTA = 0xFF; // enable internal pullups on PORTA
 3d8:	8f ef       	ldi	r24, 0xFF	; 255
 3da:	8b bb       	out	0x1b, r24	; 27
 3dc:	85 e3       	ldi	r24, 0x35	; 53
 3de:	8a 95       	dec	r24
 3e0:	f1 f7       	brne	.-4      	; 0x3de <enable_buttons+0x10>
 3e2:	00 00       	nop

	_delay_us(10);
	PORTB |= (1 << PB4) | (1 << PB5) | (1 << PB6); // enable the tristate buffer
 3e4:	88 b3       	in	r24, 0x18	; 24
 3e6:	80 67       	ori	r24, 0x70	; 112
 3e8:	88 bb       	out	0x18, r24	; 24
}
 3ea:	08 95       	ret

000003ec <debounce_switch>:

uint8_t debounce_switch(uint16_t *state, uint8_t bit)
{
 3ec:	fc 01       	movw	r30, r24
    *state = (*state << 1) | (!bit_is_clear(PINA, bit)) | 0xE000;
 3ee:	89 b3       	in	r24, 0x19	; 25
 3f0:	20 81       	ld	r18, Z
 3f2:	31 81       	ldd	r19, Z+1	; 0x01
 3f4:	22 0f       	add	r18, r18
 3f6:	33 1f       	adc	r19, r19
 3f8:	30 6e       	ori	r19, 0xE0	; 224
 3fa:	90 e0       	ldi	r25, 0x00	; 0
 3fc:	02 c0       	rjmp	.+4      	; 0x402 <debounce_switch+0x16>
 3fe:	95 95       	asr	r25
 400:	87 95       	ror	r24
 402:	6a 95       	dec	r22
 404:	e2 f7       	brpl	.-8      	; 0x3fe <debounce_switch+0x12>
 406:	81 70       	andi	r24, 0x01	; 1
 408:	90 70       	andi	r25, 0x00	; 0
 40a:	28 2b       	or	r18, r24
 40c:	39 2b       	or	r19, r25
 40e:	31 83       	std	Z+1, r19	; 0x01
 410:	20 83       	st	Z, r18
	
    if (*state == 0xF000)
        return 1;
 412:	81 e0       	ldi	r24, 0x01	; 1
 414:	90 ef       	ldi	r25, 0xF0	; 240
 416:	20 30       	cpi	r18, 0x00	; 0
 418:	39 07       	cpc	r19, r25
 41a:	09 f0       	breq	.+2      	; 0x41e <debounce_switch+0x32>
 41c:	80 e0       	ldi	r24, 0x00	; 0

    return 0;
}
 41e:	08 95       	ret

00000420 <poll_buttons>:

char poll_buttons(char reg)
{
	char buttons = 0;
 420:	e0 e2       	ldi	r30, 0x20	; 32
 422:	f1 e0       	ldi	r31, 0x01	; 1

    return 0;
}

char poll_buttons(char reg)
{
 424:	60 e0       	ldi	r22, 0x00	; 0
 426:	70 e0       	ldi	r23, 0x00	; 0
	char buttons = 0;
 428:	80 e0       	ldi	r24, 0x00	; 0
	static uint16_t state[] = {0, 0, 0, 0, 0, 0, 0, 0};
	
	uint8_t i;
	for (i = 0; i < BYTE; i++) {
		if (debounce_switch(&state[i], i))
			buttons |= (1 << i);
 42a:	a1 e0       	ldi	r26, 0x01	; 1
 42c:	b0 e0       	ldi	r27, 0x00	; 0
 42e:	05 c0       	rjmp	.+10     	; 0x43a <poll_buttons+0x1a>
 430:	6f 5f       	subi	r22, 0xFF	; 255
 432:	7f 4f       	sbci	r23, 0xFF	; 255
	char buttons = 0;

	static uint16_t state[] = {0, 0, 0, 0, 0, 0, 0, 0};
	
	uint8_t i;
	for (i = 0; i < BYTE; i++) {
 434:	68 30       	cpi	r22, 0x08	; 8
 436:	71 05       	cpc	r23, r1
 438:	21 f1       	breq	.+72     	; 0x482 <poll_buttons+0x62>
	PORTB |= (1 << PB4) | (1 << PB5) | (1 << PB6); // enable the tristate buffer
}

uint8_t debounce_switch(uint16_t *state, uint8_t bit)
{
    *state = (*state << 1) | (!bit_is_clear(PINA, bit)) | 0xE000;
 43a:	49 b3       	in	r20, 0x19	; 25
 43c:	20 81       	ld	r18, Z
 43e:	31 81       	ldd	r19, Z+1	; 0x01
 440:	22 0f       	add	r18, r18
 442:	33 1f       	adc	r19, r19
 444:	30 6e       	ori	r19, 0xE0	; 224
 446:	50 e0       	ldi	r21, 0x00	; 0
 448:	06 2e       	mov	r0, r22
 44a:	02 c0       	rjmp	.+4      	; 0x450 <poll_buttons+0x30>
 44c:	55 95       	asr	r21
 44e:	47 95       	ror	r20
 450:	0a 94       	dec	r0
 452:	e2 f7       	brpl	.-8      	; 0x44c <poll_buttons+0x2c>
 454:	41 70       	andi	r20, 0x01	; 1
 456:	50 70       	andi	r21, 0x00	; 0
 458:	24 2b       	or	r18, r20
 45a:	35 2b       	or	r19, r21
 45c:	21 93       	st	Z+, r18
 45e:	31 93       	st	Z+, r19
	
    if (*state == 0xF000)
 460:	40 ef       	ldi	r20, 0xF0	; 240
 462:	20 30       	cpi	r18, 0x00	; 0
 464:	34 07       	cpc	r19, r20
 466:	21 f7       	brne	.-56     	; 0x430 <poll_buttons+0x10>
	static uint16_t state[] = {0, 0, 0, 0, 0, 0, 0, 0};
	
	uint8_t i;
	for (i = 0; i < BYTE; i++) {
		if (debounce_switch(&state[i], i))
			buttons |= (1 << i);
 468:	9d 01       	movw	r18, r26
 46a:	06 2e       	mov	r0, r22
 46c:	02 c0       	rjmp	.+4      	; 0x472 <poll_buttons+0x52>
 46e:	22 0f       	add	r18, r18
 470:	33 1f       	adc	r19, r19
 472:	0a 94       	dec	r0
 474:	e2 f7       	brpl	.-8      	; 0x46e <poll_buttons+0x4e>
 476:	82 2b       	or	r24, r18
 478:	6f 5f       	subi	r22, 0xFF	; 255
 47a:	7f 4f       	sbci	r23, 0xFF	; 255
	char buttons = 0;

	static uint16_t state[] = {0, 0, 0, 0, 0, 0, 0, 0};
	
	uint8_t i;
	for (i = 0; i < BYTE; i++) {
 47c:	68 30       	cpi	r22, 0x08	; 8
 47e:	71 05       	cpc	r23, r1
 480:	e1 f6       	brne	.-72     	; 0x43a <poll_buttons+0x1a>
		if (debounce_switch(&state[i], i))
			buttons |= (1 << i);
	}

	return buttons;
}
 482:	08 95       	ret

00000484 <spi_init>:
#include <avr/io.h>
#include "macros.h"

void spi_init()
{
	DDRB |= 0x07;  //set output mode for SS, MOSI, SCLK
 484:	87 b3       	in	r24, 0x17	; 23
 486:	87 60       	ori	r24, 0x07	; 7
 488:	87 bb       	out	0x17, r24	; 23
	SPCR = (1 << SPE) | (1 << MSTR); //set master mode, clk low on idle, leading edge sample
 48a:	80 e5       	ldi	r24, 0x50	; 80
 48c:	8d b9       	out	0x0d, r24	; 13
	SPSR = (1 << SPI2X);  //set choos
 48e:	81 e0       	ldi	r24, 0x01	; 1
 490:	8e b9       	out	0x0e, r24	; 14
}
 492:	08 95       	ret

00000494 <spi_send>:

char spi_send(char msg)
{
	SPDR = msg; //set SPDR to start the transmission
 494:	8f b9       	out	0x0f, r24	; 15

	while (!ISSET(SPSR, SPIF)); // wait until transmission is complete
 496:	77 9b       	sbis	0x0e, 7	; 14
 498:	fe cf       	rjmp	.-4      	; 0x496 <spi_send+0x2>
	
	return SPDR; // return the byte that was received
 49a:	8f b1       	in	r24, 0x0f	; 15
}
 49c:	08 95       	ret

0000049e <enable_graph>:
#include "spi_driver.h"
#include "macros.h"

void enable_graph()
{
	DDRD |= 0x01; // set PD0 to an output
 49e:	88 9a       	sbi	0x11, 0	; 17
	
	CLRBIT(PORTD, PD0); // clear PD0
 4a0:	90 98       	cbi	0x12, 0	; 18
	spi_init(); // initialize the spi interface
 4a2:	0e 94 42 02 	call	0x484	; 0x484 <spi_init>
}
 4a6:	08 95       	ret

000004a8 <update_graph>:

char update_graph(char value)
{
	char result = spi_send(value); // send the given value via spi
 4a8:	0e 94 4a 02 	call	0x494	; 0x494 <spi_send>
	strobel(PORTD, PD0); // set PD0 and then clear it
 4ac:	90 9a       	sbi	0x12, 0	; 18
 4ae:	90 98       	cbi	0x12, 0	; 18

	return result; // return the result read from spi
}
 4b0:	08 95       	ret

000004b2 <__vector_12>:
#include "spi_driver.h"
#include "encoder_driver.h"
#include "macros.h"

ISR(TIMER1_COMPA_vect)
{
 4b2:	1f 92       	push	r1
 4b4:	0f 92       	push	r0
 4b6:	0f b6       	in	r0, 0x3f	; 63
 4b8:	0f 92       	push	r0
 4ba:	11 24       	eor	r1, r1

}
 4bc:	0f 90       	pop	r0
 4be:	0f be       	out	0x3f, r0	; 63
 4c0:	0f 90       	pop	r0
 4c2:	1f 90       	pop	r1
 4c4:	18 95       	reti

000004c6 <poll_encoders>:

char poll_encoders()
{
	strobeh(PORTE, PE6); // latch the encoder state
 4c6:	1e 98       	cbi	0x03, 6	; 3
 4c8:	1e 9a       	sbi	0x03, 6	; 3
	
	return spi_send(0x00); // send garbage in order to receive the state
 4ca:	80 e0       	ldi	r24, 0x00	; 0
 4cc:	0e 94 4a 02 	call	0x494	; 0x494 <spi_send>
}
 4d0:	08 95       	ret

000004d2 <init_encoder_struct>:

void init_encoder_struct(struct encoder_state *state)
{
 4d2:	cf 93       	push	r28
 4d4:	df 93       	push	r29
 4d6:	ec 01       	movw	r28, r24
	/* set the current encoder directions to stopped */
 4d8:	82 e0       	ldi	r24, 0x02	; 2
 4da:	88 83       	st	Y, r24
	state->left_dir = STOPPED;
 4dc:	89 83       	std	Y+1, r24	; 0x01
	state->right_dir = STOPPED;

 4de:	0e 94 63 02 	call	0x4c6	; 0x4c6 <poll_encoders>
	/* get the initial value of the encoders in the shift register */
 4e2:	98 2f       	mov	r25, r24
 4e4:	93 70       	andi	r25, 0x03	; 3
 4e6:	9a 83       	std	Y+2, r25	; 0x02
	char encoders = poll_encoders();
 4e8:	99 27       	eor	r25, r25
 4ea:	87 fd       	sbrc	r24, 7
 4ec:	90 95       	com	r25
 4ee:	8c 70       	andi	r24, 0x0C	; 12
 4f0:	90 70       	andi	r25, 0x00	; 0
 4f2:	95 95       	asr	r25
 4f4:	87 95       	ror	r24
 4f6:	95 95       	asr	r25
 4f8:	87 95       	ror	r24
 4fa:	8b 83       	std	Y+3, r24	; 0x03
	state->left_last = LEFT_ENCODER(encoders);
 4fc:	df 91       	pop	r29
 4fe:	cf 91       	pop	r28
 500:	08 95       	ret

00000502 <determine_direction>:
	state->right_last = RIGHT_ENCODER(encoders);
}						 
				
uint8_t determine_direction(uint8_t cur, uint8_t last)
 502:	86 17       	cp	r24, r22
 504:	21 f0       	breq	.+8      	; 0x50e <determine_direction+0xc>
{
	if (cur == last)
		return STOPPED; // nothing has changed so it's stopped
 506:	88 23       	and	r24, r24
 508:	21 f4       	brne	.+8      	; 0x512 <determine_direction+0x10>
 50a:	61 30       	cpi	r22, 0x01	; 1
 50c:	41 f0       	breq	.+16     	; 0x51e <determine_direction+0x1c>
	
	if (cur == 0x00 && last == 0x01)
		return REVERSE;

	if (cur == 0x01 && last == 0x00)
		return FORWARD;
 50e:	82 e0       	ldi	r24, 0x02	; 2
 510:	08 95       	ret
{
	if (cur == last)
		return STOPPED; // nothing has changed so it's stopped
	
	if (cur == 0x00 && last == 0x01)
		return REVERSE;
 512:	81 30       	cpi	r24, 0x01	; 1
 514:	e1 f7       	brne	.-8      	; 0x50e <determine_direction+0xc>
 516:	66 23       	and	r22, r22
 518:	d1 f7       	brne	.-12     	; 0x50e <determine_direction+0xc>

 51a:	81 e0       	ldi	r24, 0x01	; 1
	if (cur == 0x01 && last == 0x00)
		return FORWARD;

 51c:	08 95       	ret
				
uint8_t determine_direction(uint8_t cur, uint8_t last)
{
	if (cur == last)
		return STOPPED; // nothing has changed so it's stopped
	
 51e:	80 e0       	ldi	r24, 0x00	; 0
 520:	08 95       	ret

00000522 <get_direction>:
	if (cur == 0x01 && last == 0x00)
		return FORWARD;

	return STOPPED;
}

 522:	fc 01       	movw	r30, r24
void get_direction(struct encoder_state *state, uint8_t encoders)
 524:	86 2f       	mov	r24, r22
 526:	83 70       	andi	r24, 0x03	; 3
 528:	92 81       	ldd	r25, Z+2	; 0x02
	char encoders = poll_encoders();
	state->left_last = LEFT_ENCODER(encoders);
	state->right_last = RIGHT_ENCODER(encoders);
}						 
				
uint8_t determine_direction(uint8_t cur, uint8_t last)
 52a:	89 17       	cp	r24, r25
 52c:	21 f0       	breq	.+8      	; 0x536 <get_direction+0x14>
{
	if (cur == last)
		return STOPPED; // nothing has changed so it's stopped
 52e:	88 23       	and	r24, r24
 530:	e9 f4       	brne	.+58     	; 0x56c <get_direction+0x4a>
 532:	91 30       	cpi	r25, 0x01	; 1
 534:	09 f1       	breq	.+66     	; 0x578 <get_direction+0x56>
	
	if (cur == 0x00 && last == 0x01)
		return REVERSE;

	if (cur == 0x01 && last == 0x00)
		return FORWARD;
 536:	92 e0       	ldi	r25, 0x02	; 2

	return STOPPED;
}

void get_direction(struct encoder_state *state, uint8_t encoders)
 538:	90 83       	st	Z, r25
{
 53a:	70 e0       	ldi	r23, 0x00	; 0
 53c:	6c 70       	andi	r22, 0x0C	; 12
 53e:	70 70       	andi	r23, 0x00	; 0
 540:	75 95       	asr	r23
 542:	67 95       	ror	r22
 544:	75 95       	asr	r23
 546:	67 95       	ror	r22
 548:	93 81       	ldd	r25, Z+3	; 0x03
	char encoders = poll_encoders();
	state->left_last = LEFT_ENCODER(encoders);
	state->right_last = RIGHT_ENCODER(encoders);
}						 
				
uint8_t determine_direction(uint8_t cur, uint8_t last)
 54a:	69 17       	cp	r22, r25
 54c:	31 f0       	breq	.+12     	; 0x55a <get_direction+0x38>
{
	if (cur == last)
		return STOPPED; // nothing has changed so it's stopped
 54e:	66 23       	and	r22, r22
 550:	49 f0       	breq	.+18     	; 0x564 <get_direction+0x42>
	
	if (cur == 0x00 && last == 0x01)
		return REVERSE;
 552:	61 30       	cpi	r22, 0x01	; 1
 554:	11 f4       	brne	.+4      	; 0x55a <get_direction+0x38>
 556:	99 23       	and	r25, r25
 558:	89 f0       	breq	.+34     	; 0x57c <get_direction+0x5a>

	if (cur == 0x01 && last == 0x00)
		return FORWARD;
 55a:	92 e0       	ldi	r25, 0x02	; 2

	return STOPPED;
}

void get_direction(struct encoder_state *state, uint8_t encoders)
{
 55c:	91 83       	std	Z+1, r25	; 0x01
	/* determine the new direction based on the last and latest encoder state */
	state->left_dir = determine_direction(LEFT_ENCODER(encoders), state->left_last);
 55e:	82 83       	std	Z+2, r24	; 0x02
	state->right_dir = determine_direction(RIGHT_ENCODER(encoders), state->right_last);
 560:	63 83       	std	Z+3, r22	; 0x03

 562:	08 95       	ret
}						 
				
uint8_t determine_direction(uint8_t cur, uint8_t last)
{
	if (cur == last)
		return STOPPED; // nothing has changed so it's stopped
 564:	91 30       	cpi	r25, 0x01	; 1
 566:	c9 f7       	brne	.-14     	; 0x55a <get_direction+0x38>
	
 568:	90 e0       	ldi	r25, 0x00	; 0
 56a:	f8 cf       	rjmp	.-16     	; 0x55c <get_direction+0x3a>
	if (cur == 0x00 && last == 0x01)
		return REVERSE;
 56c:	81 30       	cpi	r24, 0x01	; 1
 56e:	19 f7       	brne	.-58     	; 0x536 <get_direction+0x14>
 570:	99 23       	and	r25, r25
 572:	09 f7       	brne	.-62     	; 0x536 <get_direction+0x14>

 574:	91 e0       	ldi	r25, 0x01	; 1
 576:	e0 cf       	rjmp	.-64     	; 0x538 <get_direction+0x16>
				
uint8_t determine_direction(uint8_t cur, uint8_t last)
{
	if (cur == last)
		return STOPPED; // nothing has changed so it's stopped
	
 578:	90 e0       	ldi	r25, 0x00	; 0
 57a:	de cf       	rjmp	.-68     	; 0x538 <get_direction+0x16>
	if (cur == 0x00 && last == 0x01)
		return REVERSE;

 57c:	91 e0       	ldi	r25, 0x01	; 1
 57e:	ee cf       	rjmp	.-36     	; 0x55c <get_direction+0x3a>

00000580 <enable_encoders>:
	state->right_dir = determine_direction(RIGHT_ENCODER(encoders), state->right_last);

	/* log the last encoder state */
	state->left_last = LEFT_ENCODER(encoders);
	state->right_last = RIGHT_ENCODER(encoders);
}
 580:	16 9a       	sbi	0x02, 6	; 2

void enable_encoders()
 582:	1e 9a       	sbi	0x03, 6	; 3
{
 584:	0e 94 42 02 	call	0x484	; 0x484 <spi_init>
	DDRE |= 0x40; // set PE6 to an output
 588:	08 95       	ret

0000058a <init_encoder_timers>:
	
	SETBIT(PORTE, PE6); // set PE6
	spi_init(); // initialize the spi interface
}

 58a:	08 95       	ret

0000058c <get_encoder_state>:
void init_encoder_timers()
{
	
}
 58c:	1e 98       	cbi	0x03, 6	; 3
 58e:	1e 9a       	sbi	0x03, 6	; 3

 590:	80 e0       	ldi	r24, 0x00	; 0
 592:	08 95       	ret

00000594 <__udivmodhi4>:
 594:	aa 1b       	sub	r26, r26
 596:	bb 1b       	sub	r27, r27
 598:	51 e1       	ldi	r21, 0x11	; 17
 59a:	07 c0       	rjmp	.+14     	; 0x5aa <__udivmodhi4_ep>

0000059c <__udivmodhi4_loop>:
 59c:	aa 1f       	adc	r26, r26
 59e:	bb 1f       	adc	r27, r27
 5a0:	a6 17       	cp	r26, r22
 5a2:	b7 07       	cpc	r27, r23
 5a4:	10 f0       	brcs	.+4      	; 0x5aa <__udivmodhi4_ep>
 5a6:	a6 1b       	sub	r26, r22
 5a8:	b7 0b       	sbc	r27, r23

000005aa <__udivmodhi4_ep>:
 5aa:	88 1f       	adc	r24, r24
 5ac:	99 1f       	adc	r25, r25
 5ae:	5a 95       	dec	r21
 5b0:	a9 f7       	brne	.-22     	; 0x59c <__udivmodhi4_loop>
 5b2:	80 95       	com	r24
 5b4:	90 95       	com	r25
 5b6:	bc 01       	movw	r22, r24
 5b8:	cd 01       	movw	r24, r26
 5ba:	08 95       	ret

000005bc <_exit>:
 5bc:	f8 94       	cli

000005be <__stop_program>:
 5be:	ff cf       	rjmp	.-2      	; 0x5be <__stop_program>
